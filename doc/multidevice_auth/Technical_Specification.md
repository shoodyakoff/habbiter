# Поддержка мульти-девайс авторизации — Техническое задание

**Дата:** 2026-01-13

---

## Связанные документы
- **Проектирование:** Design.md
- **Бизнес-требования:** Business_Requirements.md

## История изменений
- 2026-01-13 - Документ создан

---

## Задача: Оптимизация авторизации для поддержки нескольких устройств

### Описание
Необходимо рефакторить логику авторизации в Edge Functions, чтобы устранить создание лишних сессий и избыточные обновления пользователя, которые приводят к сбросу авторизации на других устройствах.

---

## Что сделать

1. Рефакторинг `supabase/functions/telegram-auth/index.ts`
2. Рефакторинг `supabase/functions/telegram-auth-miniapp/index.ts`
3. Рефакторинг `supabase/functions/telegram-webhook/index.ts` (функция `authorizeUser`)
4. Рефакторинг `supabase/functions/generate-auth-token/index.ts` (action `poll`)

---

## Требования

### Общая логика авторизации (для всех функций)

Вместо текущей последовательности действий реализовать следующий алгоритм:

1. **Поиск пользователя:**
   - Выполнить запрос к таблице `public.users` по `telegram_id` используя Service Role.
   - `supabase.from('users').select('id').eq('telegram_id', telegramId).single()`

2. **Создание (если не найден):**
   - Если пользователь не найден в п.1, вызвать `supabase.auth.admin.createUser`.
   - Если `createUser` возвращает ошибку "User already exists" (рассинхрон таблиц), выполнить fallback на поиск по email (`admin.listUsers` или `signIn` только для ID, но лучше `listUsers`).

3. **Проверка метаданных:**
   - Получить объект пользователя через `supabase.auth.admin.getUserById(userId)`.
   - Сравнить текущее значение `app_metadata.is_subscribed` с новым.
   - **Условие:** Вызывать `updateUserById` ТОЛЬКО если значение изменилось.

4. **Выдача сессии:**
   - Вызвать `supabase.auth.signInWithPassword` один раз в самом конце флоу.
   - Вернуть полученную сессию клиенту.

### Детали реализации по файлам

**1. `telegram-auth/index.ts` и `telegram-auth-miniapp/index.ts`**
- Заменить блок `try/catch` вокруг `createUser` на явную проверку существования.
- Убрать промежуточный `signInWithPassword` (который использовался для получения ID).

**2. `telegram-webhook/index.ts`**
- В функции `authorizeUser`:
- Убрать лишние вызовы `signInWithPassword`.
- Реализовать условное обновление метаданных.
- Обратить внимание: вебхук сам не выдает сессию, но он готовит пользователя. `signIn` там нужен только если мы хотим проверить пароль? Нет, вебхук авторизует токен.
- В `telegram-webhook` сессия не нужна, там мы просто помечаем токен как `success`.
- **Важно:** `authorizeUser` в вебхуке создает/апдейтит юзера. Там `signIn` вообще не нужен, если мы не проверяем валидность пароля. Можно убрать `signIn` полностью, так как сессия выдается в `generate-auth-token` (polling).

**3. `generate-auth-token/index.ts`**
- В блоке `action === 'poll'`:
- Когда статус `success`, мы делаем `signInWithPassword`.
- Убедиться, что здесь нет лишних апдейтов. (Вроде нет, но проверить).

---

## Критерии приемки

```gherkin
Сценарий: Одновременная работа на двух устройствах
Дано Пользователь авторизован на Телефоне (Сессия А)
Когда Пользователь авторизуется на ПК (получает Сессию Б)
Тогда Сессия Б успешно создана
И Сессия А остается активной (пользователь может обновить страницу на Телефоне и остаться в системе)
```

```gherkin
Сценарий: Отсутствие лишних обновлений
Дано Пользователь уже существует и статус подписки не изменился
Когда Пользователь авторизуется повторно
Тогда `auth.users.updated_at` не должен измениться (или метаданные не должны перезаписываться)
И Не должно создаваться более 1 новой сессии за процесс входа
```

---

## Открытые вопросы
Нет.

## Не входит в задачу
- Изменение механизма паролей (Bot Token).
- UI управления сессиями.
