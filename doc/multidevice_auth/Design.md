# Поддержка мульти-девайс авторизации — Логическое проектирование

**Дата:** 2026-01-13
**Режим:** Scale-up

---

## Связанные документы
- **Бизнес-требования:** Business_Requirements.md
- **Контекст проекта:** Project_Context.md

## История изменений
- 2026-01-13 - Документ создан

---

## 1. Контекст задачи

### Что делаем
Исправляем проблему, при которой авторизация на новом устройстве сбрасывает сессию на предыдущих устройствах. Цель — обеспечить одновременную работу на нескольких устройствах.

### Что есть сейчас
- Авторизация реализована через Edge Functions (`telegram-auth`, `generate-auth-token`).
- Используется схема "Resource Owner Password Credentials", где паролем является `TELEGRAM_BOT_TOKEN` (общий для всех, но уникальный email).
- При каждом входе происходит:
    1. Попытка `createUser`.
    2. Если пользователь есть — **лишний** вызов `signInWithPassword` просто чтобы узнать `user_id`.
    3. Вызов `updateUserById` (обновление метаданных) при **каждом** входе.
    4. Финальный вызов `signInWithPassword` для получения сессии.

### Проблема текущего решения
- Множественные вызовы `signInWithPassword` (создание лишних сессий).
- Агрессивное обновление `updateUserById` может провоцировать инвалидацию токенов или конфликты репликации сессий (Refresh Token Rotation).
- Если в Supabase включен лимит сессий, мы его быстро исчерпываем.

### Что меняем
Оптимизируем поток авторизации в Edge Functions, чтобы минимизировать побочные эффекты и исключить лишние операции с Auth API.

---

## 2. Архитектурная схема (изменения в Edge Functions)

**Было:**
```
Client -> Edge Function
   -> Auth: createUser (Fail)
   -> Auth: signInWithPassword (Get ID) -> Создает Session A (Мусор)
   -> Auth: updateUserById (Write)
   -> Auth: signInWithPassword (Get Session) -> Создает Session B (Return)
Client <- Session B
```

**Станет:**
```
Client -> Edge Function
   -> DB: Select from public.users (Get ID via telegram_id)
   -> Если нет: Auth: createUser
   -> Auth: getUser (Check metadata)
   -> Если изменилось: Auth: updateUserById
   -> Auth: signInWithPassword (Get Session) -> Создает Session A (Return)
Client <- Session A
```

---

## 3. Варианты решения

### Вариант А: Оптимизация текущего потока (Рекомендуемый)

**Логика:**
1. Вместо "фейкового" входа для поиска пользователя используем поиск по таблице `public.users` (у нас есть `telegram_id`).
2. Проверяем текущее состояние `is_subscribed` в метаданных пользователя перед обновлением. Если не изменилось — не дергаем `updateUserById`.
3. Вызываем `signInWithPassword` ровно один раз в самом конце.

**Плюсы:**
- Минимальные изменения в коде.
- Устраняет создание "мусорных" сессий.
- Снижает нагрузку на Auth сервер.
- Сохраняет обратную совместимость.

**Минусы:**
- Сохраняется архитектурный изъян с использованием Bot Token в качестве пароля (но это за рамками задачи).

### Вариант Б: Переход на Custom JWT

**Логика:**
Вместо `signInWithPassword` генерировать свой JWT токен, подписанный секретом Supabase, и отдавать его клиенту.

**Плюсы:**
- Безопаснее (нет псевдо-паролей).
- Полный контроль над сессией.

**Минусы:**
- Требует реализации логики Refresh Token на клиенте и сервере (или сложной настройки).
- Высокий риск сломать авторизацию у всех текущих пользователей.
- Требует изменений на клиенте.

---

## 4. Рекомендация

### Выбираем: **Вариант А**

**Почему:**
1. Решает проблему "шумных" обновлений, которые вероятнее всего и являются причиной сброса сессий.
2. Безопасно для внедрения (не ломает существующие сессии).
3. Быстро в реализации.

**Trade-offs:**
- Оставляем технический долг с паролями-токенами, но фокусируемся на стабильности сессий.

---

## 5. Что меняем в системе

### Backend (Edge Functions)
**`supabase/functions/telegram-auth/index.ts`** и **`supabase/functions/telegram-auth-miniapp/index.ts`**:
- Убрать блок `catch` с `signInWithPassword` при создании пользователя.
- Добавить поиск пользователя через `supabase.from('users').select('id').eq('telegram_id', ...).single()`.
- Добавить проверку `user.app_metadata.is_subscribed !== isSubscribed` перед вызовом `updateUserById`.

**`supabase/functions/generate-auth-token/index.ts`** (poll action) и **`telegram-webhook`**:
- Аналогичная оптимизация: не создавать лишних сессий.

### Frontend
- Изменений не требуется (клиент просто получает сессию).

---

## 6. Граничные случаи

### Кейс 1: Пользователь удален из `auth.users`, но есть в `public.users`
**Условие:** Рассинхрон данных.
**Поведение:** Поиск по `public.users` вернет ID. Попытка `signInWithPassword` вернет ошибку "Invalid login credentials".
**Решение:** Если `signIn` падает, можно попробовать пересоздать пользователя (но это сложный кейс). В рамках этой задачи считаем данные синхронными.

### Кейс 2: Смена `TELEGRAM_BOT_TOKEN`
**Условие:** Разработчик сменил токен бота.
**Поведение:** Пароли всех пользователей станут неверными.
**Решение:** Это известное ограничение текущей архитектуры. Решение — миграция паролей или сброс. Не решаем в этой задаче.

---

## 7. Риски и митигация

### Риск 1: Проблема не в коде, а в настройках проекта
**Вероятность:** Средняя.
**Влияние:** Критичное (фикс кода не поможет).
**Митигация:** Проверить настройки Supabase Project -> Auth -> Sessions. Убедиться, что "Single session per user" выключен (по умолчанию выключен). Если включен — выключить. Код все равно стоит оптимизировать.

---

## 8. Ограничения и допущения

### Допущения
- Таблица `public.users` корректно индексирована по `telegram_id` (это Unique constraint, так что индекс есть).
- Сервисный ключ (Service Role Key) имеет права на чтение `public.users` и администрирование Auth.

---

## 9. Следующие шаги
- [ ] Написание технических требований (Technical_Specification.md)
- [ ] Рефакторинг Edge Functions
